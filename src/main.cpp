#define GLEW_STATIC
#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <iostream>    // Sometimes I cout
#include <fstream>     // open my model file, don't want to deal with that just yet
#include <unistd.h>    // getcwd
#include <sys/param.h> // MAXPATHLEN

#include "Common/common.h" // some things I like to use
#include "Common/math.h"   // some of the common math stuff I need
#include "Common/algebra.h" // impo

struct triangle {
    vec3f v1;
    vec3f v2;
    vec3f v3;
};

struct triangle_edges_index {
    u32 v1;
    u32 v2;
    u32 v3;
};

struct camera {
    vec3f Position;
    vec3f Forward;
    vec3f Up;
};

// This is a simple mesh generated by a model.
struct mesh3d {

    u32 VerticesBufferSize;
    u32 VerticesCount;
    vec3f* Vertices;

    u32 IndexesBufferSize;
    u32 IndexesCount;
    u32* Indexes;
};

/**
 * This will make a copy the vertices and triangle buffer.
 */
mesh3d mesh3d_Make(u32 VerticesCount, vec3f* Vertices, u32 IndexesCount, u32* Indexes)
{
    mesh3d Result;
    Result.VerticesCount = VerticesCount;
    Result.VerticesBufferSize = sizeof(vec3f) * VerticesCount;
    Result.Vertices = (vec3f*)malloc(Result.VerticesBufferSize);
    memcpy(Result.Vertices, Vertices, Result.VerticesBufferSize);

    Result.IndexesCount = IndexesCount;
    Result.IndexesBufferSize = sizeof(u32) * IndexesCount;
    Result.Indexes = (u32*)malloc(Result.IndexesBufferSize);
    memcpy(Result.Indexes, Indexes, Result.IndexesBufferSize);

    return Result;
}

u32 StrLength(char *c) {

    u32 Result = 0;
    while (c[Result++]) {}
    return Result - 1;
}

struct string {
    char *Buffer;
    u32   StringSize;
    u32   BufferSize;
};

void string_Free(string s) {
    s.BufferSize = 0; 
    s.StringSize = 0; 
    free(s.Buffer);
}

// Assuming 0-termination
string string_MakeFrom(char *Base) {
    string Result;
    Result.StringSize = StrLength(Base);
    Result.BufferSize = Result.StringSize + 1;
    Result.Buffer = (char*)malloc(Result.BufferSize);
    
    for (u32 i = 0; i < Result.StringSize; ++i) {
        Result.Buffer[i] = Base[i];
    }
    Result.Buffer[Result.StringSize] = 0;
    return Result;
}

string string_Append(string A, string B)
{
    string Result;

    Result.StringSize = A.StringSize + B.StringSize;
    Result.BufferSize = Result.StringSize + 1;
    Result.Buffer = (char*)malloc(Result.BufferSize);

    u32 WriteIndex = 0;
    for (u32 i = 0; i < A.StringSize; ++i) {
       Result.Buffer[WriteIndex++] = A.Buffer[i]; 
    }
    for (u32 i = 0; i < B.StringSize; ++i) {
       Result.Buffer[WriteIndex++] = B.Buffer[i]; 
    }
    Result.Buffer[WriteIndex] = 0;

    return Result; 
}

struct file_content {
    size_t BufferSize;
    char* Buffer;
};

file_content LoadEntireFile(std::string Location, std::ios_base::openmode openmode)
{
    file_content Result;
    auto ifsStream = std::ifstream(Location, openmode);
    if (!ifsStream.is_open()) {
        std::cout << "Error opening model file: " << std::strerror(errno) << std::endl;
        abort();
    }

    int Length;

    ifsStream.seekg(0, std::ios::end);
    Length = ifsStream.tellg();
    ifsStream.seekg(0, std::ios::beg);
    
    char* Filebuffer = (char*)malloc(Length);
    ifsStream.read(Filebuffer, Length);

    Result.BufferSize = Length;
    Result.Buffer = Filebuffer;
    return Result;
}

void FreeFileContent(file_content ShaderSource)
{
    free(ShaderSource.Buffer);
}
    
struct ifs_data {

    u32 VerticesCount;
    vec3f *Vertices;

    u32 FacesCount;
    triangle_edges_index *Faces;
};

ifs_data ParseIFSData(char* Filebuffer) {

#define GET_NEXT_SIZE (*(u32*)(Filebuffer)); Filebuffer += 4

    ifs_data Result;
    //fileheader processing      
    u32 IFSStringSize = GET_NEXT_SIZE;
    Filebuffer += IFSStringSize + sizeof(float) /*skip model version*/;

    u32 ModelNameSize = GET_NEXT_SIZE;
    Filebuffer += ModelNameSize;

    //vertexheader processing
    u32 VERTICESStrSize = GET_NEXT_SIZE; 
    Filebuffer += VERTICESStrSize;

    u32 VerticesCount = GET_NEXT_SIZE;

    //vertex processing
    size_t VerticesBufferSize = (sizeof(vec3f) * VerticesCount); 
    vec3f* Vertices = (vec3f*)malloc(VerticesBufferSize);

    for (u32 i = 0; i < VerticesCount; ++i) {
        vec3f* VerticesValue = (vec3f*)(Filebuffer);
        Vertices[i] = *VerticesValue;
        Filebuffer += sizeof(vec3f);
    }
    //triangle header processing
    u32 TriangleStrSize = GET_NEXT_SIZE; 
    Filebuffer += TriangleStrSize;

    u32 FacesCount = GET_NEXT_SIZE;

    // triangle edges processing 
    size_t FacesBufferSize = (sizeof(triangle_edges_index) * FacesCount);
    triangle_edges_index* Faces = (triangle_edges_index*)malloc( FacesBufferSize);

    for (u32 i = 0; i < FacesCount; ++i) {

        triangle_edges_index *IndexValue = (triangle_edges_index*)(Filebuffer);
        Faces[i] = *IndexValue;

        Filebuffer += sizeof(triangle_edges_index);
    }

    Result.VerticesCount = VerticesCount;
    Result.Vertices = Vertices;

    Result.FacesCount = FacesCount;
    Result.Faces = Faces;

    return Result;
#undef GET_NEXT_SIZE
}


struct {
    mesh3d ModelMesh;
} Global;


file_content LoadShaderSource(std::string Location)
{
    return LoadEntireFile(Location, std::ios::in);
}

/********************
 *  MAIN SHIT
 ********************/
void KeyCallback(GLFWwindow* Window, int Key, int Scancode __unused, int Action, int Mode __unused)
{
    if(Key == GLFW_KEY_ESCAPE && Action == GLFW_PRESS) {
        glfwSetWindowShouldClose(Window, GL_TRUE);
    }
}


void Initialisation(std::string ModelFilepath)
{
    //Get file buffer here and send it to the parser
    file_content ifsContent = LoadEntireFile(ModelFilepath, std::ios::binary);
    
    ifs_data IFSData = ParseIFSData(ifsContent.Buffer);

    mesh3d NewMesh = mesh3d_Make(IFSData.VerticesCount, IFSData.Vertices, IFSData.FacesCount * 3, (u32*)IFSData.Faces);
    Global.ModelMesh = NewMesh;

    FreeFileContent(ifsContent);
}

mat44 ViewMatrixFromCamera(camera Camera) {

    return mat44_LookAt(Camera.Position, Camera.Position + Camera.Forward, Camera.Up);
}

int main(int Argc __unused, char** Argv __unused)
{
    char CurrentWorkingDirectoryPath[MAXPATHLEN];
    getcwd(CurrentWorkingDirectoryPath, MAXPATHLEN);

    string Cwd = string_MakeFrom(CurrentWorkingDirectoryPath);
    string TeapotPath = string_MakeFrom("/data/teapot.ifs");
    string AbsoluteTeapotPath = string_Append(Cwd, TeapotPath);
     
    Initialisation(AbsoluteTeapotPath.Buffer);

    camera Camera = {.Position = vec3f(0, 0, -1), .Forward = vec3f(0, 0, 1), .Up = vec3f_Y};

    string_Free(TeapotPath);
    string_Free(AbsoluteTeapotPath);

    // I want to do some flat shading. My current understanding of OpenGL is that there are
    // no ways to get a normal per triangle, all normals are stored per vertices. This 
    // prevents me of using the vertices/indexes (called elements) based drawing.
    // The approch is to then create a expended vertex buffer and use the DrawArrays method, 
    // and calculate the assign the triangle normal as a vertex normal. Since the buffer 
    // contains duplicated vertices, a vertex might have multiple normal assigned

    // Generate the expended vertices buffer and its associated normal buffer
    u32 VerticesCount = Global.ModelMesh.IndexesCount;
    vec3f* Vertices = (vec3f*)malloc(VerticesCount * sizeof(vec3f));

    u32 NormalsCount = VerticesCount;
    vec3f* Normals = (vec3f*)malloc(NormalsCount * sizeof(vec3f));

    for (u32 i = 0; i < Global.ModelMesh.IndexesCount; i+=3) {
        
        u32 i1 = Global.ModelMesh.Indexes[i + 0];
        u32 i2 = Global.ModelMesh.Indexes[i + 1];
        u32 i3 = Global.ModelMesh.Indexes[i + 2];

        vec3f v1 = Global.ModelMesh.Vertices[i1]; 
        vec3f v2 = Global.ModelMesh.Vertices[i2]; 
        vec3f v3 = Global.ModelMesh.Vertices[i3]; 

        vec3f e1 = v2 - v1;
        vec3f e2 = v3 - v2;

        Vertices[i + 0] = v1;
        Vertices[i + 1] = v2;
        Vertices[i + 2] = v3;

        vec3f Normal = vec3f_NormalizeFrom(vec3f_Cross(e2, e1));
        Normals[i + 0] = Normal;
        Normals[i + 1] = Normal;
        Normals[i + 2] = Normal;
    }
    //End of manually computing vertices and their normals


    // Init drawing stuff
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); //macOS
    
    GLFWwindow* Window = glfwCreateWindow(800, 600, "Experiment", nullptr, nullptr);    
    if(Window == nullptr) {
        std::cout << "Cannot open window" << std::endl; 
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(Window);

    glfwSetKeyCallback(Window, KeyCallback);
    glfwSetInputMode(Window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);

    glewExperimental = GL_TRUE;
    if (glewInit() != GLEW_OK) {
        
        std::cout << "Cannot init glew" << std::endl; 
        return -1; 
    }

    int Width, Height;
    glfwGetFramebufferSize(Window, &Width, &Height);
    glViewport(0, 0, Width, Height);

    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);
    // end of drawing initlisation


    // Creating shader program
    string VertexShaderSourcePath = string_MakeFrom("/data/shaders/default.vert");
    string FragmentShaderSourcePath = string_MakeFrom("/data/shaders/default.frag");

    string VSAbsolutePath = string_Append(Cwd, VertexShaderSourcePath);
    string FSAbsolutePath = string_Append(Cwd, FragmentShaderSourcePath);

    file_content  VertexShaderSource = LoadShaderSource(VSAbsolutePath.Buffer);
    file_content  FragmentShaderSource = LoadShaderSource(FSAbsolutePath.Buffer);

    string_Free(VertexShaderSourcePath);
    string_Free(FragmentShaderSourcePath);
    string_Free(VSAbsolutePath);
    string_Free(FSAbsolutePath);


    GLuint VertexShader, FragmentShader;

    VertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(VertexShader, 1, &VertexShaderSource.Buffer, NULL);
    glCompileShader(VertexShader);

    GLint Success;
    GLchar Info[512];

    glGetShaderiv(VertexShader, GL_COMPILE_STATUS, &Success);
    if (!Success) {
        glGetShaderInfoLog(VertexShader, 512, NULL, Info);
        std::cout << "Could not compile vertex shader: " << Info << std::endl; 
        exit(1);
    }

    FragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(FragmentShader, 1, &FragmentShaderSource.Buffer, NULL);
    glCompileShader(FragmentShader);

    glGetShaderiv(FragmentShader, GL_COMPILE_STATUS, &Success);
    if (!Success) {
        glGetShaderInfoLog(FragmentShader, 512, NULL, Info);
        std::cout << "Could not compile fragment shader: " << Info << std::endl; 
        exit(1);
    }

    GLuint ShaderProgram;

    ShaderProgram = glCreateProgram();
    glAttachShader(ShaderProgram, VertexShader);
    glAttachShader(ShaderProgram, FragmentShader);
    glLinkProgram(ShaderProgram);

    glGetProgramiv(ShaderProgram, GL_LINK_STATUS, &Success);
    if(!Success) {
        glGetProgramInfoLog(ShaderProgram, 512, NULL, Info);
        std::cout << "Could not link program: " << Info << std::endl;
        exit(1);
    }

    glUseProgram(ShaderProgram);
    glDeleteShader(VertexShader);
    glDeleteShader(FragmentShader);
    FreeFileContent(VertexShaderSource);
    FreeFileContent(FragmentShaderSource);
    //Done creating shader
    
    //Generating buffers for vertices
    GLuint VAO, VBO, NBO;
    glGenBuffers(1, &VBO);
    glGenBuffers(1, &NBO);

    glGenVertexArrays(1, &VAO);

    glBindVertexArray(VAO);
        glBindBuffer(GL_ARRAY_BUFFER, VBO);
        glBufferData(GL_ARRAY_BUFFER, VerticesCount * sizeof(vec3f), (void*)Vertices, GL_STATIC_DRAW); // Computer not happy when you put this in the loop
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);

        glBindBuffer(GL_ARRAY_BUFFER, NBO);
        glBufferData(GL_ARRAY_BUFFER, NormalsCount * sizeof(vec3f), (void*)Normals, GL_STATIC_DRAW);
        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);
        
        glEnableVertexAttribArray(0);
        glEnableVertexAttribArray(1);
    glBindVertexArray(0);
    //Done generating vertices

    // Some stuff that doesn't need to be recomputed every frame
    // Not that it matters anyway, lets pretend we are efficient here
    mat33 StartRotationInterpolation = mat33_MakeRotation(vec3f_Y, M_PI_4);
    mat33 EndRotationInterpolation   = mat33_MakeRotation(vec3f_Y, M_PI_2 + M_PI_4);
    mat44 TranslationMatrix = mat44_MakeTranslate(0, 0, 3);

    mat44 View = /*ViewMatrixFromCamera(Camera);//*/mat44_LookAt(vec3f(0, 0, -1), vec3f(0, 0, 2.5), vec3f(0, 1, 0));
    mat44 Projection = mat44_Perspective(35, 0.1, 100, Width, Height);

    double LastTimeStamp = glfwGetTime();
    double TimeForFrame = 0.01666;

    while(!glfwWindowShouldClose(Window)) {

        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
        
        glfwPollEvents();

        double CurrentTime = glfwGetTime();
        double DeltaTime = CurrentTime - LastTimeStamp;

        float t = (Cosf(glfwGetTime()) + 1.0) / 2.0;

        mat33 Rotation = RotationInterpolation(StartRotationInterpolation, EndRotationInterpolation, t);
        mat44 RotationMatrix = mat44_FromMat33(Rotation);

        mat44 Model = TranslationMatrix * RotationMatrix;
        mat44 MVP = Projection * View * Model;

        //my matrices are row-major, opengl wants column-major, therefore we need to transpose
        GLint ModelLocation = glGetUniformLocation(ShaderProgram, "Model");
        glUniformMatrix4fv(ModelLocation, 1, GL_TRUE, (float*)Model.m);
        
        GLint ViewLocation = glGetUniformLocation(ShaderProgram, "View");
        glUniformMatrix4fv(ViewLocation, 1, GL_TRUE, (float*)View.m); 

        GLint MVPLocation = glGetUniformLocation(ShaderProgram, "MVP");
        glUniformMatrix4fv(MVPLocation, 1, GL_TRUE, (float*)MVP.m);

        // Draw some shit
        glBindVertexArray(VAO);
            glDrawArrays(GL_TRIANGLES, 0, VerticesCount);
        glBindVertexArray(0);

        glfwSwapBuffers(Window);

        // Me showing off i can manually manage a 60fps so that i don't use 80% because i'm drawing like a mad man
        // Obviously, it barelly works, sometime it just hangs
        while ((glfwGetTime() - CurrentTime) < TimeForFrame) { usleep(200); }
    }

    glfwTerminate();
    return 0;
}
